=pod

=head1 Unicode Data

The C<pdfout_data> is a complex data type. This is the data format used to
interface with the parsers and emitters described below.

It is organized into 3 different types:

=over

=item * Scalar:

A scalar holds an UTF-8 string, which may contain embedded null bytes and does
not have to be null-terminated.

=item * Array:

An array holds an array of pointers to C<pdfout_data> types.

=item * Hash:

A hash is a set of key-value pairs. Both key and value are pointers to
C<pdfout_data> types. The keys must be unique scalars.

=back

=head2 Functions


=head3 Type queries

 bool pdfout_data_is_scalar (fz_context *ctx, pdfout_data *data);
 bool pdfout_data_is_array (fz_context *ctx, pdfout_data *data);
 bool pdfout_data_is_hash (fz_context *ctx, pdfout_data *data);

=head3 Scalars

Create a new scalar with

 pdfout_data *pdfout_data_scalar_new (fz_context *ctx, const char *value,
					 int len);

Return the value of a scalar with

 char *pdfout_data_scalar_get (fz_context *ctx, pdfout_data *scalar, int *len);

where the length of the string is stored in C<*len>.

=head3 Arrays

Create a new array with

 pdfout_data *pdfout_data_array_new (fz_context *ctx);

The length of an array is obtained with

 int pdfout_data_array_len (fz_context *ctx, pdfout_data *array);

Elements of an array are accessed with

 pdfout_data *pdfout_data_array_get (fz_context *ctx, pdfout_data *array,
				     int pos);

New elements are appended with

 void pdfout_data_array_push (fz_context *ctx, pdfout_data *array,
			      pdfout_data *entry);

=head3 Hashes

Create a new hash with

 pdfout_data *pdfout_data_hash_new (fz_context *ctx);

The number of key-value pairs in a hash is obtained with

 int pdfout_data_hash_len (fz_context *ctx, pdfout_data *hash);

New key-value pairs are appended with

 void pdfout_data_hash_push (fz_context *ctx, pdfout_data *hash,
         	             pdfout_data *key, pdfout_data *value);

C<key> has to be a scalar. The keys in a hash must be
unique. Trying to add a key which is already present in the hash will throw an
exception.

There are multiple functions to access a hashes key-value pairs.

 pdfout_data *pdfout_data_hash_get_key (fz_context *ctx, pdfout_data *hash,
				        int i);
 pdfout_data *pdfout_data_hash_get_value (fz_context *ctx, pdfout_data *hash,
					  int i);
					 
These extract key and value of the i-th key-value pair.

 pdfout_data *pdfout_data_hash_gets (fz_context *ctx, pdfout_data *hash,
				     char *key);

Searches the hash for the key C<key> and returns the key's value. If no key is
found, NULL is returned.

=head3 Destructor

 void pdfout_data_drop (fz_context *ctx, pdfout_data *data);

Recursively free.



=head1 JSON Parsing

Parse and emit JSON, as defined in
L<RFC 7159|https://tools.ietf.org/html/rfc7159>.

=head2 Synopsis

  const char *json = "[42, true, \"xxx\"]";

  fz_stream *stm = fz_open_memory (ctx, (unsigned char *) json, strlen (json));
  json_parser *parser = json_parser_new (ctx, stm);

  char *number;
  int len;

  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_BEGIN_ARRAY);
  
  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_NUMBER);
  assert (strcmp (number, "42") == 0 && len == 2);

  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_TRUE);

  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_STRING);
  assert (strcmp (number, "xxx") == 0 && len == 3);

  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_END_ARRAY);
  
  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_EOF);
  
  assert (json_parser_parse (ctx, parser, &number, &len) == JSON_INVALID);

  json_parser_drop (ctx, parser);
  fz_drop_stream (ctx, stm);

=head2 API

Each time the JSON Parser is called, it produces a parsing event of type C<enum
json_token>. The possible events are:

=over

=item JSON_INVALID

The parser encountered invalid JSON.

=item JSON_EOF

The parser reached the end of file. In particular, the JSON is valid.

=item JSON_STRING

The event includes the contents and length of the string.

=item JSON_NUMBER

The event includes the contents and length of the number.

=item JSON_FALSE

=item JSON_NULL

=item JSON_TRUE

=item JSON_BEGIN_ARRAY

=item JSON_END_ARRAY

=item JSON_BEGIN_OBJECT

=item JSON_END_OBJECT

=back

=head3 Functions

=over

=item

 json_parser *json_parser_new (fz_context *ctx, fz_stream *stm);

Return a new parser, which will read from C<stm>. Increase the refcount of
C<stm>. Throw on error.

=item

 void json_parser_drop (fz_context *ctx, json_parser *parser);

Deallocate C<parser> and decrease the refcount of the underlying stream.

=item

 json_token json_parser_parse (fz_context *ctx, json_parser *parser,
                               char **value, int *value_len);

Get the next parsing event and return it's type. For the JSON_STRING and
JSON_NUMBER events, C<*value> and C<*value_len> will hold the parsed string or
number. Calling this function again after a JSON_EOF was encountered will
return JSON_INVALID.

 
=back